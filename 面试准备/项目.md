# 项目


## 专业技能
+ 熟悉Java语法、集合等基础框架
+ 对JVM原理有初步理解，了解相关基础知识
+ 熟练使用mysql、oracle等主流关系型数据库
+ 熟练掌握SpringBoot、Mybatis等开源框架，以及Maven等项目构建工具
+ 熟悉RabbitMQ消息中间件的使用
+ 掌握HTML、CSS、JavaScript、vue


## 工作经历
招银网络科技有限公司(杭州) Java工程师 - 2019.7月 - 2020.12月

@RefreshScope
## 项目经历
---
+ 项目描述： 
信用卡参数管理系统重构及优化。由于业务流量需求不断增多，参数管理模块与业务系统紧耦合，重复的编码工作成为了最主要的痛点，需要对系统参数以及业务参数进行集中管理及复核，将参数模块微服务化。
+ 责任描述：
    + 参数复核中心后端


+ 涉及技术：SpringBoot、Mybatis、mysql、redis等



## 资料采集子系统 es 存储申请书数据（大宽表）
mysql + ES保证数据一致性
[https://www.v2ex.com/t/601156](https://www.v2ex.com/t/601156)

所以每次业务操作只更新一次 ES，如果发生错误或者异常，在数据库中插入一条补救任务，有 Worker 任务会实时地扫这些数据，以数据库订单数据为基准来再次更新 ES 数据。通过此种补偿机制，来保证 ES 数据与数据库订单数据的最终一致性。

## 信用卡进度管理系统
es 存储需要检索的字段，不用检索的数据放mysql里

es document 模型设计
1对多的关系 [https://www.bilibili.com/video/BV1gE411M7cs?p=28&spm_id_from=pageDriver](https://www.bilibili.com/video/BV1gE411M7cs?p=28&spm_id_from=pageDriver)
es里的数据模型
写入的时候就完成join操作

## 使用缓存  高性能 别说是为了高并发（没有多大的并发）
zookeeper 缓存服务


　首先来看看Archaius解决了什么问题，在大型分布式系统中，在大型分布式系统中经常会存在下面的几类问题：

　　　　1.需用从配置中新获取配置，加载到本地内存。

　　　　2.配置中心的配置发生变化，需要动态更新本地内存中的配置。

　　　　3.配置中心的配置发生变换，需要接收通知。

　　archaius如何解决上面的问题：

　　　　其实archaius解决方法很简单，就是定时从配置中心去读取数据，并且更新内存中相关配置，并且通知监听的监听器更新内容。

大量服务，修改配置后，需要一个一个进行刷新

https://www.jianshu.com/p/a6a7c91efd5c


+ 为什么不直接使用zookeeper的节点存储数据
    +   理论上来说，ZooKeeper可以保存任何数据，你可以把数据转换成byte类型。ZooKeeper虽然提供了在节点存储数据的功能，但它并不将自己定位为一个通用的数据库，也就是说，你不应该在节点存储过多的数据，因为数据过大会导致zk的性能明显下降。
    +   还有一点，由于ZooKeeper集群会自动进行数据的同步，数据量太大对网络也是有影响的。


## 痛点
+ 业务中流量需求很多，比如新增一些小功能，或者要对之前的功能进行改进；需要开发人员进行开发，通常来说一般会需要用到一些系统参数或者业务参数，或者需要新建一些对应功能的参数表
+ 系统上线后，业务人员需要修改指定的业务参数，指定一些规则，希望配置的参数能够生效；比如说配置一些筛选规则让一些不符合条件的案件转入人工处理等；
+ 以往的做法是对于这些参数，在第一次查询的时候缓存进入jvm内存中，同时提供一个刷新系统缓存的接口，业务人员可以通过修改完参数后调用缓存刷新接口进行缓存刷新；
+ 但是经过系统拆分，微服务化，多实例部署后，经常会出现部分实例缓存刷新不到的情况，因为我们的docker容器平台的访问策略是轮训或者配置流量比例的，所以经常需要开发人员去机房手动刷新多次才能生效
+ 此外，因为业务拆分，数据库垂直分库界限划分不清，导致许多时候这个业务系统需要用到另外一个业务系统的数据表(主机下放数据)；就需要同构一张相同的表到自己业务系统的数据库内，同时还要需要考虑一个数据同步的问题
+ 如果是同一种类型的关系型数据库还好，如果是不同的数据库，比如说对方是DB2，我们是mysql，就会有很多麻烦的地方

---
这类缓存的特点
+ 对性能有要求
+ 不经常变化
+ 占用内存不大
+ 有访问整个集合的需求
+ 经常被大量的读取，更新频率低
---
最终实现的功能
+ 本地缓存增量更新
+ 如果是缓存查不到，再查DB。切记一定要加上锁，不然如果多个线程同时去查缓存，然后查不到，然后又同时去查DB，线程足够多，有可能出现穿透DB的情况。
+ 
***总结下来主要有两个问题，第一个问题是多实例的缓存同步刷新问题，第二个问题是异构数据源缓存数据***
## 解决方案

@RefreshScope

针对消息通知这个问题，我们想了一些解决方案：
+ 使用现有的配置中心，springcloud config或者nacos实现修改配置，通知多实例生效；这种情况如果说是只是用到一个开关，一个flag那么可以；但是我们的情况是很复杂的，大多数情况下并不是一个系统参数这么简单
+ 而且大多数情况下这些参数是业务参数，需要业务人员去配置，总不能让业务人员去操作配置文件吧
+ 但是可以借鉴这些思想，比如利用mq这一个消息总线，各个系统订阅topic，刷新的时候往broker塞数据，每个实例消费到更新数据就进行缓存刷新
+ 考虑我们已经有基于zookeeper的配置中心，已经有部分业务系统接入了， 在此基础上，我们想基于zookeeper这个分布式协调中间件，利用它的节点监听机制，实现多实例缓存的同步刷新

针对不同数据库的数据缓存问题，我们的想法是：
+ 不用zookeeper节点存储缓存的原因是，zookeeper的节点本身虽然有存储数据的功能，但是它的定位不是数据库，存储过多的数据可能会导致性能下降，而且集群间同步的IO网络开销也增大了
+ 每次刷新缓存，系统就不去查询对应的数据库了
+ 由统一的缓存管理服务，通过不同的数据源，将需要的数据统一读取放到redis中
+ 收到缓存刷新的实例，去redis中重新拿取数据即可
+ 通过这样一种方式，完成数据的读取更新
---
我们在此想法的基础之上，完成了基于zookeeper与redis的缓存同步刷新服务，主要功能包括：
+ 提供服务所需数据源配置
+ 提供springboot的自动装配包，通过简单的配置，快速引入，在服务中通过简单的缓存操作即可拿到想要的数据
+ 全量刷新（灰度刷新）
+ 降级策略
    + zookeeper不可用了，告警，发短信通知，设置了后台定时轮询对比内存中的版本号与redis中的版本号，如果不一致进行更新的兜底策略
    + redis不可用了，那问题比较严重，首先我们使用的是redis集群模式，3个master，3个slave，每个实例16GB，4核CPU，1T磁盘，redis进程8G，持久化机制AOF和RDB都开启了，有专门的人维护和监控，而且我们的场景主要针对与一些参数，涉及的量并不大，其次我们是***读少写少***，只有业务需求，需要改变某些规则的时候，才去修改。如果真的挂了的话，我们还有一层JVM内存作为兜底，同时给出了接口去修改JVM中的内存，保证不至于redis挂了，我们就没法运作了
    + 如果真的挂了，那么你的业务系统也应该做相应的兜底，比如我们有一套自己的异常消息重处理服务，通过把失败异常的案件通过消息队列发送给这个服务，之后进行重试；在此期间，我们尽快恢复redis，保证可用
    + 如何保证我们的缓存刷新服务高可用，首先我们在三个集群，前海、西丽、蛇口分别部署了一套，一个挂了还有另一个；其次还是这个情况，我们的场景读少写少，挂的可能性不大，同时我们由于要查询不同的数据库，为了数据库异常，我们还对缓存刷新服务做了资源隔离，就我们自己的这个业务场景来说，我觉的已经很大程度上可以保证高可用了

+ 涉及技术：SpringBoot、Mybatis、mysql、redis、zookeeper、vue等

+ 责任描述：
    + 参与系统设计与评审
    + 参数同步刷新功能开发
    + 前端页面开发


## 为什么不实用redis的订阅发布功能做推送
##数据可靠性无法保证

一个redis-cli发布消息n个redis-cli接受消息。消息的发布是无状态的，即发布完消息后该redis-cli便在理会该消息是否被接受到，是否在传输过程中丢失，即对于发布者来说，消息是”即发即失”的.

##扩展性太差

不能通过增加消费者来加快消耗发布者的写入的数据，如果发布者发布的消息很多，则数据阻塞在通道中已等待被消费着来消耗。阻塞时间越久，数据丢失的风险越大(网络或者服务器的一个不稳定就会导致数据的丢失)


----
客户端和服务端保持了一个长连接，从而能第一时间获得配置更新的推送。（通过Http Long Polling实现）
客户端还会定时从Apollo配置中心服务端拉取应用的最新配置。
这是一个fallback机制，为了防止推送机制失效导致配置不更新
客户端定时拉取会上报本地版本，所以一般情况下，对于定时拉取的操作，服务端都会返回304 - Not Modified
定时频率默认为每5分钟拉取一次，客户端也可以通过在运行时指定System Property: apollo.refreshInterval来覆盖，单位为分钟。
客户端从Apollo配置中心服务端获取到应用的最新配置后，会保存在内存中
客户端会把从服务端获取到的配置在本地文件系统缓存一份
在遇到服务不可用，或网络不通的时候，依然能从本地恢复配置
应用程序可以从Apollo客户端获取最新的配置、订阅配置更新通知

--- 
可用性考虑
|场景|影响|降级|原因|
|---|---|---|---|
|前端应用挂了|客户端无影响，缓存服务端无影响||尝试其他pod|
|某台缓存服务宕机了|客户端无影响，缓存服务端无影响||k8s|
|缓存服务全部down了|客户端无法获取最新的参数信息|降级使用本地之前的缓存，直到缓存服务重新上线||
|zookeeper挂了|缓存服务无法主动推送更新信息|客户端配置了轮询拉取缓存服务最新数据，同时有相应的告警短信通知||
|redis挂了|无影响|客户端定时上报版本，服务端发现版本需要更新，客户端查询的时候，主动查询数据库||
|数据库挂了|影响换粗刷新|降级使用客户端JVM缓存||
|客户端挂了|影响客户端业务|客户端本身需要有相应的熔断，降级策略，使用兜底的异常消息处理服务，在服务恢复后进行重试||

