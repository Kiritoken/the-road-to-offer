# 模拟题

## 死锁的成立条件
1、互斥条件：任意时刻一个资源只能给一个进程使用，其他进程若申请一个资源，而该资源被另一进程占有时，则申请者等待直到资源被占有者释放。

2、不可剥夺条件：进程所获得的资源在未使用完毕之前，不被其他进程强行剥夺，而只能由获得该资源的进程资源释放。

3、请求和保持条件：进程每次申请它所需要的一部分资源，在申请新的资源的同时，继续占用已分配到的资源。

4、循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。

## 说明一下cookie跟session的差别，用途
因为Http协议是无状态的，所以服务器需要记录用户状态时，需要某些机制记录用户状态，session会话记录了这个状态，通常存在与服务器的内存中或者数据库，redis中。
而cookie可以帮助我们实现记录sessionId的作用，通过在http头部中设置cookie存储sessionId，可以让后端读取cookie中的sessionId。所以说cookie是实现session的一种方式，其主要区别有：
+ cookie存在与客户端（浏览器）
+ session存在与服务器
+ cookie还可以记录一些其他的信息
+ 如果浏览器设置了禁用cookie，还可以通过重写url的方式传递seesionID


## 给定一个字符串，请你找出其中不含有重复字符的最长子串的长度。
滑动窗口，双指针

## mysql的锁粒度有哪些，意向锁是什么
+ myaism
    + 表锁

+ innoDB
    + 表锁 加锁快，不会出现死锁，并发低
        + 共享锁（S锁）
        加锁之后其他用户对同一表可读不可写
        + 排他锁（x锁）
        加锁之后，其他用户对同一表不可读写
    + 表锁 加锁慢，会出现死锁，锁定粒度下，并发高
        + 共享锁 
        加锁之后，其他用户对同一行可读不可写
        + 排他锁
        加锁之后，其他用户对同一行不可写但是可读（因为 innoDB 的 select 默认是快照读，不上锁）

## 意向锁
 意向锁的存在价值在于在定位到特定的行所持有的锁之前，提供一种更粗粒度的锁，可以大大节约引擎对于锁的定位和处理的性能，因为在存储引擎内部，锁是由一块独立的数据结构维护的，锁的数量直接决定了内存的消耗和并发性能。例如，事务A对表t的某些行修改（DML通常会产生X锁），需要对t加上意向排它锁，在A事务完成之前，B事务来一个全表操作（alter table等），此时直接在表级别的意向排它锁就能告诉B需要等待（因为t上有意向锁），而不需要再去行级别判断。 
 + 考虑以下这种情况：
 事务A对该表加了行排他锁，禁止其他事务对改行进行修改；
 事务B对该表加了排他表锁，B禁止其他事务对该表进行修改，这时候就出现了矛盾；
 所以事务B要去判断是否已经加了行锁，现在有这样的方法：
 + 判断是否已经被加了表锁
 + 判断每行是否已经加了行锁
 显然第二个步骤需要遍历所有行，开销极大，所以引入了意向锁，事务A再进行加锁之前先申请表的意向写锁，事务B在去判断的时候只要判断是否已经被加了表锁或者是意向锁即可，而不需要去行级判断


 ## https和http的差别
 + http使用80端口，https使用443端口
 + http使用明文传输，https使用加密的ssl加密传输协议


 ## 扫雷地雷生成，n*m矩阵生成k个雷

 ## 最短路径算法
[https://www.cnblogs.com/biyeymyhjob/archive/2012/07/31/2615833.html](https://www.cnblogs.com/biyeymyhjob/archive/2012/07/31/2615833.html)

## 一个请求从浏览器发出，然后返回数据给前端展示，描述一下过程
+ 输入网址
+ DNS解析，获取服务器ip
+ 建立tcp连接（三次握手）
+ 发送http请求
+ 服务器接受响应处理数据
+ 四次挥手释放连接
+ 客户端拿到数据进行渲染

## 三次握手
（1）第一次握手：Client将标志位SYN置为1（表示要发起一个连接），随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。
（2）第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。
（3）第三次握手：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。


### 为什么需要三次握手
+ 确认双方的接受能力与发送能力
+ 为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误
client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接
## 四次挥手
（1）第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。
（2）第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。
（3）第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。
（4）第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。

## 限流算法
[https://segmentfault.com/a/1190000017078491](https://segmentfault.com/a/1190000017078491)
[https://github.com/doocs/advanced-java/blob/main/docs/high-concurrency/huifer-how-to-limit-current.md](https://github.com/doocs/advanced-java/blob/main/docs/high-concurrency/huifer-how-to-limit-current.md)
+ ***计数器法***
顾名思义,计数器算法是指在一定的时间窗口内允许的固定数量的请求.比如,2s内允许10个请求,30s内允许100个请求等等.如果设置的时间粒度越细,那么相对而言限流就会越平滑,控制的粒度就会更细.
    + 弊端
    假设1min内服务器的负载能力为100，因此一个周期的访问量限制在100，然而在第一个周期的最后5秒和下一个周期的开始5秒时间段内，分别涌入100的访问量，虽然没有超过每个周期的限制量，但是整体上10秒内已达到200的访问量，已远远超过服务器的负载能力，由此可见，计数器算法方式限流对于周期比较长的限流，存在很大的弊端
    + 实现
redis的ttl特性完美的满足了这一需求,将时间窗口设置为key的失效时间,然后将key的值每次请求+1即可.伪代码实现思路:
```java
//1.判断是否存在该key
if(EXIT(key)){
  // 1.1自增后判断是否大于最大值,并返回结果
  if(INCR(key) > maxPermit){
     return false;
  }
 return true;
}

//2.不存在key,则设置key初始值为1,失效时间为3秒
SET(KEY,1);
EXPIRE(KEY,3);
```

+ 漏桶算法
桶的容量是固定的,并且水流以一个固定的速率流出；
流入的水流可以是任意速率；
如果流入的水流超出了桶的容量，则后续流入的水流溢出(请求被丢弃)。
如果桶内没有水,则不需要流出
    + 弊端
    如果短时间内流量激增，漏桶算法不能很好的自适应调整
    + 实现方式
        可以利用队列进行实现，队列满了后，进行丢弃

+ 令牌桶算法
令牌桶算法算是漏斗算法的改进版,为了处理短时间的突发流量而做了优化,令牌桶算法主要由三部分组成令牌流、数据流、令牌桶
令牌桶算法会按照一定的速率生成令牌放入令牌桶,访问要进入系统时,需要从令牌桶获取令牌,有令牌的可以进入,没有的被抛弃.由于令牌桶的令牌是源源不断生成的,当访问量小时,可以留存令牌达到令牌桶的上限,这样当短时间的突发访问量来时,积累的令牌数可以处理这个问题.当访问量持续大量流入时,由于生成令牌的速率是固定的,最后也就变成了类似漏斗算法的固定流量处理.
    + 实现思路
    实现方式和漏斗也比较类似,可以使用一个队列保存令牌,一个定时任务用等速率生成令牌放入队列,访问量进入系统时,从队列获取令牌再进入系统.
    Google开源的guava包中RateLimiter类实现了令牌桶算法,不过这是单机的.集群可以按照上面的实现方式实现,队列使用中间件MQ实现,配合负载均衡算法,考虑集群各个服务器的承压情况做对应服务器的队列是比较建议的做法.