# list
list 是一个有序（按加入的时许排序）的数据结构，redis采用quicklist（双端链表）和ziplist作为list的底层实现




## 阻塞队列的实现方式

redisDb维护了一个阻塞的dict，key是队列的名字，value是监听这个队列的client


## 底层实现

### ziplist
为了节省内存
紧凑的二进制数据结构

+ 优点
    + 节省空间，如果使用prev next，两个指针至少16个字节
    + 每个节点数据量太大

+ 缺点
    + 不擅长做修改，一旦数据发生改动，可能会引起连锁更新，引发节点的重新分配


### quicklist
快速链表
双向链表与压缩列表的组合 

当链表entry数据超过512、或单个value 长度超过64，底层就会转化成linkedlist编码；
linkedlist是标准的双向链表，Node节点包含prev和next指针，可以进行双向遍历；
***还保存了 head 和 tail 两个指针，因此，对链表的表头和表尾进行插入的复杂度都为 (1) —— 这是高效实现 LPUSH 、 RPOP、 RPOPLPUSH 等命令的关键。***


因为双向链表占用的内存比压缩列表要多， 所以当创建新的列表键时， 列表会优先考虑使用压缩列表， 并且在有需要的时候， 才从压缩列表实现转换到双向链表实现。

双向链表里存的就是压缩链表，链表于链表之间用prev 和 next指针串联起来
+ 单个ziplist节点最大能存储8kb，超过则进行分裂，将新的数据存储在新的ziplist节点中

+ 压缩算法进行压缩，避免内存碎片化


## 压缩列表转化成双向链表条件
创建新列表时 redis 默认使用 redis_encoding_ziplist 编码， 当以下任意一个条件被满足时， 列表会被转换成 redis_encoding_linkedlist 编码：
    试图往列表新添加一个字符串值，且这个字符串的长度超过 server.list_max_ziplist_value （默认值为 64 ）。
    ziplist 包含的节点超过 server.list_max_ziplist_entries （默认值为 512 ）。



## ziplist连锁更新的问题
因为在ziplist中，每个zlentry都存储着前一个节点所占的字节数，而这个数值又是变长编码的。假设存在一个压缩列表，其包含e1、e2、e3、e4…..，e1节点的大小为253字节，那么e2.prevrawlen的大小为1字节，如果此时在e2与e1之间插入了一个新节点e_new，e_new编码后的整体长度（包含e1的长度）为254字节，此时e2.prevrawlen就需要扩充为5字节；如果e2的整体长度变化又引起了e3.prevrawlen的存储长度变化，那么e3也需要扩…….如此递归直到表尾节点或者某一个节点的prevrawlen本身长度可以容纳前一个节点的变化。其中每一次扩充都需要进行空间再分配操作。删除节点亦是如此，只要引起了操作节点之后的节点的prevrawlen的变化，都可能引起连锁更新。

连锁更新在最坏情况下需要进行N次空间再分配，而每次空间再分配的最坏时间复杂度为O(N)，因此连锁更新的总体时间复杂度是O(N^2)。
即使涉及连锁更新的时间复杂度这么高，但它能引起的性能问题的概率是极低的：需要列表中存在大量的节点长度接近254的zlentry。



## 阻塞队列的实现
blpop 、 brpop 和 brpoplpush这个几个阻塞命令的实现原理：

只有当这些命令被用于空列表时， 它们才会阻塞客户端。
阻塞一个客户端需要执行以下步骤：

将客户端的状态设为“正在阻塞”，并记录阻塞这个客户端的各个键，以及阻塞的最长时限（timeout）等数据。
将客户端的信息记录到 server.db[i]->blocking_keys 中（其中 i 为客户端所使用的数据库号码）。
继续维持客户端和服务器之间的网络连接，但不再向客户端传送任何信息，造成客户端阻塞。
步骤 2 是将来解除阻塞的关键， server.db[i]->blocking_keys 是一个字典， 字典的键是那些造成客户端阻塞的键， 而字典的值是一个链表， 链表里保存了所有因为这个键而被阻塞的客户端 （被同一个键所阻塞的客户端可能不止一个）：