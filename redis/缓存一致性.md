# 缓存数据库双写一致性
[https://www.cnblogs.com/rjzheng/p/9041659.html](https://www.cnblogs.com/rjzheng/p/9041659.html)

# cache aside pattern
读的时候，先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。
更新的时候，先更新数据库，然后再删除缓存。 


## 依赖过期时间，到达最终一致
从理论上来说，给缓存设置过期时间，是保证最终一致性的解决方案。这种方案下，我们可以对存入缓存的数据设置过期时间，所有的写操作以数据库为准，对缓存操作只是尽最大努力即可。也就是说如果数据库写成功，缓存更新失败，那么只要到达过期时间，则后面的读请求自然会从数据库中读取新值然后回填缓存。


## 删除库存的时候失败了
先更新数据库，后删除缓存中的值，如果这时候删除缓存失败了怎么办

+ 改成先删除缓存，再更新数据库
虽然整个数据是旧数据，至少能保证数据库和缓存的数据是一致的

## 最终解决方案

不管是先删除缓存再更新数据库，还是先更新数据库再删除缓存都存在问题
具体问题还是要具体看待，首先先确定业务场景，如果需要强一致性性，可以使用内存队列异步话串行方案，如果不是强一致性的话，而紧紧要求最终一致性的话，可以使用缓存延时双删策略

+ 延时双删策略
    + 先删除缓存
    + 更新数据库
    + 延时后再删除缓存
保证期间产生的脏数据被删除

也可以将后面的删除使用异步消息队列进行删除
或者订阅binlog，一个线程订阅binlog，异步删除缓存，删除失败进行重试
