# 20210207

+ 类的主动使用与被动使用
+ JVM运行时数据区
+ Runtime Class
+ hotspot jvm的线程都与操作系统的线程直接映射
+ 守护线程 普通线程 垃圾回收守护线程
+ 线程是jvm级别的
+ 程序计数器 pc register
+ pc 计数器的举例
+ 并行和并发的区别 cpu时间片 并发某个时间段内一起执行 某个时间点只有一个任务在执行
+ 虚拟机栈的主要特点
+ 栈是运行时的单位，堆是存储的单位
+ 栈帧（stack frame）对应一个个方法
+ 栈帧的内部结构
    + 局部变量表
        + 长度编译时已经确定，运行时不会改变
        + this 变量放在第一个slot中
        + slot的重复利用
        + 局部变量初始化（显示赋值 ）
        + 和gc的可达性分析相关
    + 操作数栈
        + 深度编译时已经确定好
        + i++和++i的区别
        + 栈顶缓存技术
    + 动态链接
        + 指向运行时常量池的方法和引用
        + 运行时常量池在方法区内
        + 常量池的作用提供一些常量和复合，便于指令的识别
    + 方法返回地址
    + 一些附加信息

+ **方法的调用**<br>
 将符号引用转变为调用方法的直接引用与方法的绑定机制相关
  + 静态链接（早期绑定）<br>
    被调用的方法在编译期间可知，且运行期间保持不变
  + 动态链接（晚期绑定）<br>
    ***被调用的方法在编译期间无法确定*** **多态**
  + 调用指令：
    + invokestatic
    + invokespecial
    + invokevirtual
    + invokeinterface
    + invokedynamic
 + **虚方法表**在链接阶段的解析环节建立，存储在方法区中

+ Class.forName 和ClassLoader的区别：<br>
    Class.forName 会进行初始化类的初始化，即默认执行静态代码块的赋值等
    ClassLoader默认不进行resolve