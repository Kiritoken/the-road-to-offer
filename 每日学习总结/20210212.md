# 20210212

+ 运行时常量池 vs 常量池
    + 运行时常量池是方法区的一部分
    + 常量池是字节码文件的一部分，这部分经过类加载后存放到方法区的运行时常量池中
    + 运行时常量池较常量池具有另一个重要特征：动态性 String.inetern()

+ class 信息
+ 为什么需要常量池 
    + 避免字节码文件过大，将数据存到常量池内，字节码存储指向常量池的引用，在动态链接时将符号引用转换为直接引用
+ 常量池内存储的信息有
    + 数量值 字面量 编译期就已经确定
    + 字符串值 字面量 编译期就已经确定
    + 类引用
    + 字段引用
    + 方法引用
+ 类加载过程中的链接阶段最后的解析过程，就是将字节码文件中常量池内的符号引用转换为运行时常量池内的直接引用的过程，属于静态链接。因为编译的时候，字节码文件并不知道，方法在内存中的地址，所以使用的时符号引用。
+ 动态链接指的是在程序运行期间，将使用到的符号引用转换为直接引用

+ 运行时常量池的理解
+ 方法区的具体使用图例
+ 方法区的演进细节
    + jdk1.6及之前，有永久代，静态变量存放在永久代中
    + jdk1.7，字符串常量池、静态变量移除，保存在堆中
    + jdk1.8之后，无永久代，有元空间，***字符串常量池、静态变量仍然在堆中***，元空间使用的是native memory
+ 永久代为什么要被元空间替代
    为了兼容jRocket
    + 永久代设置空间大小比较难确定
    + 永久代调优困难
+ stringtable 为什么要调整位置
    + jdk7之前字符串常量池在方法区永久代中，永久代回收效率比较低，基本不动方法区，方法区的回收要靠full GC触发，，这就导致stringtable回收效率低，而开发过程中会有大量的字符串创建，导致不能及时回收，所以之后将字符串常量池移动到类堆中，单是它仍然是方法区中的一部分
+ new出来的对象始终是在堆空间，引用在局部变量表    

+ 方法区的垃圾回收
    + 方法区主要回收的是运行时常量池里废弃的常量以及不再使用的类型
    + 判断一个类型是否属于不再使用的类，需要同时满足以下三个条件：
        + 该类的所有实例已经被回收，该类的所有派生对象实例也不存在
        + 加载该类的类加载器已经被回收
        + 该类的Class对象没有在任何地方被引用，无法在任何地方提供反射访问该类的方法

+ 运行时数据区总结
    + 动态链接指的是指向当前类的运行时常量池的引用

+ 面试中的问题
    + 蚂蚁金服
        + ***为什么有两个幸存者区***
    + 小米：
        + 为什么要有新生代和老年代
            + ***使用复制算法，避免产生内存碎片化***
            + 触发minor GC会将存活的对象存放到幸存者区，如果只有一个幸存者区，会导致内存碎片化，使用复制算法可以避免出现这种问题
    + 字节跳动
        + 什么时候对象会进入老年代
    + 京东
        + eden 和幸存者区的比例
        + 新生代为什么要分为eden和survivor

+ 幸存者区大小会变化的原因是用了AdaptiveSizePolicy，和垃圾回收有关，见垃圾回收方法