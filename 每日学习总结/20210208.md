# 20210208

+ 栈帧
    + 方法返回地址
        + 正常执行完成
        + 异常执行完成
    + 一些附加信息
+ 虚拟机栈的5道面试题
    + 举例栈溢出的情况（StackOverflowError）
        + -Xss 设置栈的大小
    + 调整栈大小，就能保证不出现溢出吗
    + 分配的栈内存越大越好吗
    + 垃圾回收是否涉及到虚拟机栈
      + 不涉及
      + 方法区、heap涉及到GC
    + 方法中定义的局部变量是否线程安全
        + 逃逸分析<br>
            在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是如果经过逃逸分析后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配。这样就无需在堆上分配内存，也无须进行垃圾回收了。

+ 本地方法接口 本地方法库
+ 本地方法栈
+ 上半部分总结
+ 堆(heap)
    + 进程唯一，线程共享
    + -Xms -Xmx
    + 物理上不连续，逻辑上连续
    + 方法结束后，堆中的对象不会马上被销毁，而是在垃圾回收后才回收
    + 堆的细分内存结构
        + 新生代
        + 老年代
        + 永久代（jdk8 元空间）
    + 默认初始堆空间大小为内存的1/64
    + 默认堆空间最大为内存的1/4
    + 开发中建议将初始堆空间与最大堆空间值设置为一样的值
    + jps  jstat -gc 进程号
    + 同一时刻sc0区和sc1区只能有一个区存放数据
    + OOM：Java Heap Space
+ jvisualvm 工具的使用
+ +PrintGCDetails
