# 20210211
+ 方法区
+ 垃圾回收较多回收新生代，较少回收老年代，基本不动方法区
+ Person person = new Person()<br>
   方法区  虚拟机栈 堆
+ Java 引用类型refrence是占**4个字节**
+ Java对象存在一个到该对象数据类型的指针，即class对象，存储在方法区中
+ HotSpot方法区看作是一个对立于堆的内存空间
+ 方法区为线程共享
+ ***方法区的大小决定了可以存储多少个类，如果定义类太多的类，导致方法区溢出，会抛出OOM：MetaSpace***
    + 大量动态生成的反射类
    + drools？
+ 关闭JVM会释放方法区内存
+ 方法区的引进过程
+ JDK8 元空间使用的本地内存(native memory)而不是虚拟机里分配的内存空间
+ 方法区可以设定为固定大小，也可以自动扩充收缩
+ JDK8 以后： -XX:MetaSpaceSize=100m
+ 元空间大小如果达到了MetaSpaceSize设置的大小，将会触发Full GC，fullGC 将会卸载没用的类，然后这个水平线将会被重制
+ 优化技巧 ***如果程序启动后发现频繁出现full GC，建议将MetaSpaceSize调大一点***

+ ***面试能够想到的调优经验，程序启动时频繁发生FullGC，后经过研究drools源码发现，drools将规则文件动态编译成字节码文件并进行加载，生产上规则较多，导致最后的类实例较多，元空间频繁full GC进行扩充；***
    + 需要深究drools源码
    + 需要进行垃圾回收分析

+ 如何解决OOM
    + dump 堆转储快照

+ **方法区的内部结构**
    + 类型信息
        + 全名（包名.类名）
        + 类修饰符
        + 直接父类
        + 直接接口的一个有序列表（可以实现多个接口）
    + 运行时常量池
    + 静态变量
    + JIT代码缓存
    + 域信息
        + 域名称，修饰符
    + 方法信息
        + 方法名
        + 返回类型
        + 修饰符
        + 异常表
        + 字节码 、局部变量表和操作数栈大小

+ 全局常量  static fianl
+ 每个全局常量在编译的时候就被分配了 （静态常量在编译的时候值就已经确定）
+ 静态变量在类加载中的准备环节会进行半初始化，赋0值，之后的初始化环节完成初始化
+ 区分静态变量和静态常量的区别