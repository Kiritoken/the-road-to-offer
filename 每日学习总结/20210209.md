# 20210209

## 堆
+ 年轻代和老年代
    + -XX:NewRatio=2 设置新生代与老年代比例，默认值是2，即老年代占2/3
    + 老年代存储的是生命周期长的对象
    + 默认Eden:s0:s1 = 8:1:1 -XX:SurvivorRatio=8

+ 对象分配的一般过程
    + 新分配的对象存储在伊甸园区
    + 伊甸园区满了之后，触发minor GC，此时会有STW***(Stop-The-World: Java应用程序的其他所有线程都被挂起（除了垃圾收集帮助器之外）。Java中一种全局暂停现象，全局停顿，所有Java代码停止，native代码可以执行，但不能与JVM交互；这些现象多半是由于gc引起。)*** 没有被回收的对象被存储进幸存者区内，清空伊甸园区。
    +  再次触发minor GC后，将幸存的对象存储到幸存者TO区，同时对From区进行垃圾回收，幸存者Form区内的对象需不需要回收，如果不需要回收，则也移动到TO区，此时From 与 TO区互换 ，同时对象的年龄++；
    + 每次minor GC总会有一个幸存者区是空的，并且为TO区
    + 如果在幸存者区的对象年龄超过15（年龄计数器，），即经过了15次minor GC，这个对象将被晋升Promotion，放到老年代中；
    + 可以设置晋升时的年龄临界值，通过参数 -XX:MaxTenuringThreshold=<N> 进行设置
    + **伊甸园区满时会触发minor GC，但是幸存者区满时不会触发minor GC** 伊甸园区满了时的minro GC会触发伊甸园区和幸存者区一起回收，幸存者区属于被动回收
    + 当幸存者区满了时，会直接触发晋升老年代；

+ 对象分配的特殊情况
    + 老年代空间不足，触发Major GC
    + Major GC后还不够的话，触发OOM；

+ 代码举例分配过程

+ 常用调优工具
    + VisualVM
    + JProfile
    + GCViewer

+ minor GC MajorGc FullGc
    + 部分收集：不是完整收集整个Java堆的垃圾回收
        + 新生代收集（minor GC/Young GC）
        + 老年代收集 （major GC/Old GC）只是老年代的垃圾回收
        + 混合收集 （Mixed GC）：收集整个新生代以及部分老年代的垃圾回收
    + 整堆收集（Full GC）：收集整个java堆和方法去的垃圾回收

+ major GC 的执行速度比minor GC满10倍以上，STW时间更长 ，major GC后堆空间还不足，就出现OOM；    

+ full GC触发的机制：
    + System.gc();
    + 老年代空间不足；
    + 方法区空间不足；
    + 通过minor GC进入了老年代的的平均大小大于老年代的可用内存；
    + 又幸存者区对象转移到老年代区，且老年代空间不足时；

+ 字符串常量池以前存在方法区，现在时存储在堆空间；
+ 堆分代思想：
    + 分代的唯一理由就是优化GC性能；
    + 对象的生命周期是不同的，大多是对象都是朝生夕死；

+ 动态对象年龄判断： 如果幸存者空间中相同年龄的对象大于幸存者区空间的一半，则直接移入老年代中，无需等待到达最大年龄阈值；
+ -Xms60m -Xmx60m -XX:NewRatio=2 -XX:SurvivorRatio=8 -XX:+PrintGCDetails


+ TLAB (Thread Loacl Allocation Buffer)
    + JVM为每一个线程在Eden区域划分了一块独有的区域
    + 默认占Eden空间的1%
    + 是线程专有的内存分配区域
    + 多线程下在堆上分配对象空间是需要同步机制进行加锁实现，TLAB为每个线程提供了一块独有的堆空间分配指针，不需要同步加锁，所以更加高效
    + **堆空间全都是线程所共有的吗？ 不是，还存在TLAB是线程独有的**

+ 堆空间常用参数设置
    + -Xms    
    + -Xmx
    + -Xss
    + -Xmn
    + jinfo -flag XXX xxx

## 逃逸分析
+ 如果经过逃逸分析后发现，一个对象并没有逃逸出方法的话，那么就有可能被优化成栈上分配
+ 如何快速判断是否发生了逃逸，new 的对象是否在方法外被调用
+ 代码优化：
    + 栈上分配
    + 同步省略(锁消除)<br>
    如果一个对象被发现只能从一个线程被访问到，那么对于这个对象不考虑同步
    + 标量替换
+ 逃逸分析本身也是一个耗时的问题    

---
## ***对象实例都是分配在堆上的，虽然有栈上分配，但是JVM并没有这么做，主要运用的还是标量替换，所有对象实例还是分配在堆上***